// src/utils/pdfGenerator.js

import { jsPDF } from 'jspdf';
import 'jspdf-autotable';

// 한글 폰트 파일을 import 합니다.
import NanumGothic from '../font/NanumGothic-Regular.ttf';

export function generatePDF(data) {
  const doc = new jsPDF();
  
  // 한글 폰트를 추가합니다.
  doc.addFont(NanumGothic, 'NanumGothic', 'normal');
  doc.setFont('NanumGothic');

  // 페이지 설정
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 10;
  const usableWidth = pageWidth - 2 * margin;

  // 헤더 추가
  doc.setFillColor(70, 130, 180);
  doc.rect(0, 0, pageWidth, 40, 'F');
  
  // 제목 추가
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(24);
  doc.text('Language Learning Session', pageWidth / 2, 25, { align: 'center' });

  // 날짜 추가
  const today = new Date().toLocaleDateString();
  doc.setFontSize(12);
  doc.text(`Date: ${today}`, margin, 38);

  let yPosition = 50;

  // =========== Conversation 섹션 ===========
  doc.setFillColor(100, 149, 237);
  doc.rect(margin, yPosition, usableWidth, 10, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(16);
  doc.text('Conversation', margin + 5, yPosition + 7);
  yPosition += 15;

  // 대화 텍스트 준비
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(12);
  
  // 어휘 단어 목록 정의
  const vocabularyWords = extractVocabularyWords(data.vocabulary);
  
  // 줄바꿈 처리를 위해 텍스트 분할
  const conversationLines = doc.splitTextToSize(data.conversation, usableWidth - 10);
  
  // 페이지 넘김 확인
  if (yPosition + conversationLines.length * 7 > pageHeight - margin) {
    doc.addPage();
    yPosition = margin;
  }

  // 텍스트 렌더링
  doc.text(conversationLines, margin + 5, yPosition);
  
  // 단어별 하이라이트 적용 (수정된 함수)
  applyHighlights(doc, conversationLines, yPosition, margin, vocabularyWords);
  
  // 텍스트 다시 렌더링 (하이라이트 위에)
  doc.text(conversationLines, margin + 5, yPosition);
  
  yPosition += conversationLines.length * 7 + 15;

  // =========== Translation 섹션 ===========
  doc.setFillColor(100, 149, 237);
  doc.rect(margin, yPosition, usableWidth, 10, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(16);
  doc.text('Translation', margin + 5, yPosition + 7);
  yPosition += 15;

  doc.setTextColor(0, 0, 0);
  doc.setFontSize(12);
  const translationLines = doc.splitTextToSize(data.translation, usableWidth - 10);
  
  // 페이지 넘김 확인
  if (yPosition + translationLines.length * 7 > pageHeight - margin) {
    doc.addPage();
    yPosition = margin;
  }
  
  doc.text(translationLines, margin + 5, yPosition);
  yPosition += translationLines.length * 7 + 15;

  // =========== Vocabulary 섹션 ===========
  doc.setFillColor(100, 149, 237);
  doc.rect(margin, yPosition, usableWidth, 10, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(16);
  doc.text('Vocabulary', margin + 5, yPosition + 7);
  yPosition += 15;

  // 어휘 표 생성 (발음 정보 포함)
  const vocabRows = parseVocabulary(data.vocabulary);
  
  doc.autoTable({
    startY: yPosition,
    head: [['단어', '발음', '의미']],
    body: vocabRows,
    theme: 'grid',
    styles: {
      cellPadding: 3,
      fontSize: 10,
      font: 'NanumGothic',
      overflow: 'linebreak'
    },
    headStyles: {
      fillColor: [180, 180, 255],
      textColor: [0, 0, 0],
      fontStyle: 'bold'
    }
  });

  // 푸터 추가
  doc.setFontSize(10);
  doc.setTextColor(100, 100, 100);
  doc.text('Generated by Language Learning Assistant', pageWidth / 2, pageHeight - 10, { align: 'center' });

  // PDF 저장
  doc.save("language_learning_session.pdf");
}

// 단어 추출 함수 - 수정
function extractVocabularyWords(vocabularyText) {
  if (!vocabularyText) return [];
  
  const words = [];
  const lines = vocabularyText.split('\n');
  
  lines.forEach(line => {
    // 숫자, 단어, 발음, 의미 패턴을 찾음 (정규표현식 수정)
    const match = line.match(/(\d+)\.\s*([\w\s-]+?)(?:\s*\(([^)]+)\))?\s*[-:]?\s*(.*)/);
    if (match && match[2]) {
      const word = match[2].trim();
      words.push(word);
    }
  });
  
  return words;
}

// 어휘 파싱 함수 - 다양한 형식 지원
function parseVocabulary(vocabularyText) {
  if (!vocabularyText) return [];
  
  const result = [];
  const lines = vocabularyText.split('\n');
  
  lines.forEach(line => {
    // 파이프(|) 구분자로 나누어진 형식 확인
    if (line.includes('|')) {
      // 라인에서 번호 부분 제거
      const contentPart = line.includes('.') ? line.split('.', 2)[1].trim() : line.trim();
      
      // 파이프로 구분된 부분 추출
      const parts = contentPart.split('|');
      if (parts.length >= 3) {
        const word = parts[0].trim();
        const pronunciation = parts[1].trim();
        const meaning = parts[2].trim();
        
        result.push([word, pronunciation, meaning]);
      } else if (parts.length === 2) {
        // 발음 정보가 없는 경우
        result.push([parts[0].trim(), "", parts[1].trim()]);
      }
    } else {
      // 괄호를 사용한 형식 (1. word (발음) - 의미)
      const bracketMatch = line.match(/(\d+)\.\s*([\w\s-]+?)\s*\(([^)]+)\)\s*[-:]\s*(.*)/);
      if (bracketMatch && bracketMatch[2]) {
        result.push([bracketMatch[2].trim(), bracketMatch[3].trim(), bracketMatch[4].trim()]);
      } else {
        // 일반 형식 (1. word - 의미)
        const simpleMatch = line.match(/(\d+)\.\s*([\w\s-]+?)\s*[-:]\s*(.*)/);
        if (simpleMatch && simpleMatch[2]) {
          result.push([simpleMatch[2].trim(), "", simpleMatch[3].trim()]);
        } else {
          // 공백으로 구분된 형식 (단어 발음 의미)
          const spaceParts = line.trim().split(/\s+/);
          if (spaceParts.length >= 3) {
            // 첫 번째 항목이 숫자인지 확인
            let startIndex = 0;
            if (/^\d+\.?$/.test(spaceParts[0])) {
              startIndex = 1;
            }
            
            if (spaceParts.length >= startIndex + 3) {
              const word = spaceParts[startIndex];
              const pronunciation = spaceParts[startIndex + 1];
              const meaning = spaceParts[startIndex + 2];
              
              result.push([word, pronunciation, meaning]);
            }
          }
        }
      }
    }
  });
  
  // 파싱이 제대로 되지 않았을 경우 대체 방법 시도
  if (result.length === 0 && vocabularyText.trim() !== '') {
    console.log("어휘 항목이 파싱되지 않았습니다. 대체 파싱 시도...");
    
    // 공백으로 구분된 형식으로 다시 시도
    const lines2 = vocabularyText.split('\n');
    for (const line of lines2) {
      const trimmedLine = line.trim();
      if (trimmedLine === '' || trimmedLine === '언어 학습 도우미에서 생성됨') continue;
      
      const parts = trimmedLine.split(/\s+/);
      if (parts.length >= 3) {
        result.push([parts[0], parts[1], parts[2]]);
      }
    }
  }
  
  return result;
}

// 하이라이트 적용 함수는 변경 없음
function applyHighlights(doc, lines, startY, margin, vocabularyWords) {
  const fontSize = doc.getFontSize();
  // 세로 길이 축소 (고정값)
  const highlightHeight = 6; // 더 작은 세로 길이
  
  // 각 줄에 대해 처리
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineY = startY + (i * 7);
    
    // 각 어휘 단어에 대해 처리
    for (const word of vocabularyWords) {
      // 소문자로 변환하여 대소문자 구분 없이 검색
      const lineLower = line.toLowerCase();
      const wordLower = word.toLowerCase();
      
      let pos = 0;
      
      // 한 줄에서 모든 단어 출현 검색
      while ((pos = lineLower.indexOf(wordLower, pos)) !== -1) {
        // 단어 경계 확인
        const prevChar = pos > 0 ? lineLower.charAt(pos - 1) : ' ';
        const nextChar = pos + wordLower.length < lineLower.length ? 
                        lineLower.charAt(pos + wordLower.length) : ' ';
        
        const isWordBoundaryBefore = !/[a-z0-9]/i.test(prevChar);
        const isWordBoundaryAfter = !/[a-z0-9]/i.test(nextChar);
        
        if (isWordBoundaryBefore && isWordBoundaryAfter) {
          // 원본 대소문자를 유지한 실제 단어
          const actualWord = line.substring(pos, pos + wordLower.length);
          
          // 정확한 위치 계산
          const startX = margin + 5 + (doc.getStringUnitWidth(line.substring(0, pos)) * fontSize / doc.internal.scaleFactor);
          
          // 단어 너비 계산 (글자 수에 비례)
          const wordWidth = doc.getStringUnitWidth(actualWord) * fontSize / doc.internal.scaleFactor;
          
          // 형광펜 효과 - 더 작은 세로 길이
          doc.setFillColor(255, 255, 0); // 노란색
          
          // 중앙 정렬되도록 위치 조정
          const highlightY = lineY - highlightHeight/2 + 1; // 약간 위로 조정
          
          // 하이라이트 적용 (세로 길이 고정, 가로 길이는 글자 수에 비례)
          doc.rect(startX, highlightY, wordWidth, highlightHeight, 'F');
        }
        
        // 다음 검색을 위해 위치 이동
        pos += wordLower.length;
      }
    }
  }
}